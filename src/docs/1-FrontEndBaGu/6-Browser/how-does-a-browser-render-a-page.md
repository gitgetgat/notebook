# 浏览器渲染页面的过程是怎样的？

<article-info/>

当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。

![/421a11af-691a-5f63-e3a6-d286db85e10b.png](/421a11af-691a-5f63-e3a6-d286db85e10b.png)

在 `事件循环机制` 的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。

整个渲染流程分为多个阶段，分别是： `HTML 解析`、`样式计算`、`布局`、`分层`、`绘制`、`分块`、`光栅化`、`画`

![/26c5695c-1c82-54a3-b24b-bdeba716c772.png](/26c5695c-1c82-54a3-b24b-bdeba716c772.png)

每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。

这样，整个渲染流程就形成了一套组织严密的生产流水线。

## 解析 HTML

![/54bfb060-103c-bdf1-c366-bda1302483f7.png](/54bfb060-103c-bdf1-c366-bda1302483f7.png)

解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个 `预解析的线程`，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。

![/e0370d3a-8881-6b40-9764-7a1b3949072f.png](/e0370d3a-8881-6b40-9764-7a1b3949072f.png)

如果主线程解析到 `link` 位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。

如果主线程解析到 `script` 位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。

![/d80caa6c-d4a4-9101-0ef0-b86800f69954.png](/d80caa6c-d4a4-9101-0ef0-b86800f69954.png)

第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。

![/c8466746-bfa1-944f-63b3-89c0b5e0907d.png](/c8466746-bfa1-944f-63b3-89c0b5e0907d.png)

![/231e2172-082c-f510-7438-0e0ec09042ba.png](/231e2172-082c-f510-7438-0e0ec09042ba.png)

![/d7104908-6473-ac3a-05ee-a82b38eb22af.png](/d7104908-6473-ac3a-05ee-a82b38eb22af.png)

## 样式计算

主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。

在这一过程中，很多预设值会变成绝对值，比如`red`会变成`rgb(255,0,0)`；相对单位会变成绝对单位，比如`em`会变成`px`

这一步完成后，会得到一棵带有样式的 DOM 树。

![/45edec5f-415c-4143-997b-a19e321fd1ea.png](/45edec5f-415c-4143-997b-a19e321fd1ea.png)

CSS 计算属性全过程可以看这里：[CSS 计算属性全过程](../2-CSS/css-property-calculation-process.md)

计算样式的获取：`getComputedStyle`

## 布局

布局完成后会得到布局树。

布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对 [包含块](../2-CSS/what-is-a-css-containing-block.md) 的位置。

大部分时候，DOM 树和布局树并非一一对应。

比如 `display:none` 的节点没有几何信息，因此不会生成到布局树；又比如使用了 `伪元素选择器`，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。

![/80437e6a-94c0-de3d-c8ad-80d3f932fbcf.png](/80437e6a-94c0-de3d-c8ad-80d3f932fbcf.png)

![/2dcae7e5-05f3-bcca-f93d-bdc6adb3d43c.png](/2dcae7e5-05f3-bcca-f93d-bdc6adb3d43c.png)

![/76fe6778-b97d-90a6-1bce-88c51b555b68.png](/76fe6778-b97d-90a6-1bce-88c51b555b68.png)

![/9bd98cb0-d64f-49fc-8f34-6513315f1388.png](/9bd98cb0-d64f-49fc-8f34-6513315f1388.png)

## 分层

主线程会使用一套复杂的策略对整个布局树中进行分层。

分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。

滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响到浏览器的分层决策，从而会影响到分层结果，也可以通过 `will-change` 属性更大程度的影响分层结果。

![/55cb5092-2dd8-ddf9-3886-bc70c5f73f83.png](/55cb5092-2dd8-ddf9-3886-bc70c5f73f83.png)

如何通过浏览器查看页面分层：

![/e71b648a-7f08-af94-f4c9-64841a75c590.png](/e71b648a-7f08-af94-f4c9-64841a75c590.png)

## 绘制

主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。

![/91269c92-c7bc-cb5f-11bb-cd8a700a698d.png](/91269c92-c7bc-cb5f-11bb-cd8a700a698d.png)

![/03e78ebf-1f09-a9ec-f062-b9c20e94233b.png](/03e78ebf-1f09-a9ec-f062-b9c20e94233b.png)

## 分块

完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。

合成线程首先对每个图层进行分块，将其划分为更多的小区域。

它会从线程池中拿取多个线程来完成分块工作。

![/6b4733a8-d3e1-ece5-77b5-5817cd763eeb.png](/6b4733a8-d3e1-ece5-77b5-5817cd763eeb.png)

![/7aefbac9-ad26-4e6c-ccce-1166b5f9b611.png](/7aefbac9-ad26-4e6c-ccce-1166b5f9b611.png)

## 光栅化

合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。

GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。

光栅化的结果，就是一块一块的位图

![/77fd9a2a-8a5e-b58e-5748-51f19e0b7664.png](/77fd9a2a-8a5e-b58e-5748-51f19e0b7664.png)

![/b7bb476e-6e92-e598-2501-cba589576a41.png](/b7bb476e-6e92-e598-2501-cba589576a41.png)

---

## 画

合成线程拿到每个层、每个块的位图后，生成一个个 `「指引（quad）」`信息。

![/fdabfdf6-a4e2-ca07-f61f-79075c7e88be.png](/fdabfdf6-a4e2-ca07-f61f-79075c7e88be.png)

指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。

变形发生在合成线程，与渲染主线程无关，这就是 `transform` 效率高的本质原因。

合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。

![/8731d5d2-db50-f29b-922e-f384f6feaba9.png](/8731d5d2-db50-f29b-922e-f384f6feaba9.png)

::: warning ⚠️ 注意
注意：中转 gpu 进程调用硬件，为了安全。不让渲染主线程调用硬件，隔离了与硬件的联系。

# 谈谈对 Vue 生命周期的理解

<article-info/>

组件从创建到销毁的过程就是它的生命周期

![/2339469e-69d6-9289-a586-f79239cf9d72.png](/2339469e-69d6-9289-a586-f79239cf9d72.png)

## 创建钩子

- `beforeCreate`
  在实例初始化之后，数据观测(`data observer`) 和 `event/watcher` 事件配置之前被调用。这个阶段属性、方法都不能调用
- `created`
  实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(`data observer`)，属性和方法的运算， `watch/event` 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。可以使用数据、修改数据，不会触发 `updated` 也不会更新视图。
  `主要应用`：`调用数据`，`调用方法`，`调用异步函数`

## 挂载钩子

- `beforeMount`
  在挂载开始之前被调用：相关的 `render` 函数（模板）首次被调用。完成了模板的编译，`虚拟 DOM` 也完成创建，即将渲染，修改数据，不会触发 `updated`
- `mounted`
  `el` 被新创建的 `vm.$el` 替换，并挂载到实例上去之后调用该钩子；
  把编译好的模版挂载到页面上，这里发送异步请求也可以访问 `DOM 节点`。

## 更新钩子

- `beforeUpdate`
  数据更新时调用，发生在 `虚拟 DOM` 重新渲染和打补丁之前。数据是新的，视图是旧的，组件即将更新，准备渲染， 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。
  当我们更改 Vue 的任何数据，都会触发该函数
- `updated`
  由于数据更改导致的 `虚拟 DOM` 重新渲染和打补丁，在这之后会调用该钩子。
  当这个钩子被调用时，`组件 DOM` 已经更新，组件和数据都是新的，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。
  `*该钩子在服务器端渲染期间不被调用*`。
  数据更新就会触发（vue 所有的数据只有有更新就会触发）,如果想数据一遍就做统一的处理，可以用这个，如果想对不同数据的更新做不同的处理可以用 `nextTick`，或者是 `watch` 进行监听

## 销毁钩子

- `beforeDestroy`
  实例销毁之前调用。在这一步，实例仍然完全可用，实例上所有的 `data` 和 `methods`，以及过滤器、指令等等 都还处于 <imp-text-success>可用状态</imp-text-success>。可以消除定时器等等。
- `destroyed`
  `Vue 实例`销毁后调用。调用后，`Vue 实例`指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。
  当执行到 `destroyed` 钩子函数的时候，组件已经被完全销毁了，此时 `Vue实例` 所有的`data`、`methods`、`过滤器`、`指令`... 都用不了

## keep-alive 的生命周期

- `activated`
  组件激活时触发
- `deactivated`
  组件销毁时触发

页面第一次进入的时候，钩子触发的顺序是`created -> ounted -> activated -> deactivated`

页面退出的时候会触发`deactivated`，当再次前进或者后退的时候只触发`activated`

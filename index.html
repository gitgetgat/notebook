<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <canvas id="myCanvas" width="1680" height="830"></canvas>
</body>

</html>
<!-- <script src="mapJson.js"></script> -->
<script>
  // å½“å‰ canvas çš„ 0 0 åæ ‡ï¼Œæˆ‘ä»¬è®¾ç½® canvas å·¦ä¸Šè§’é¡¶ç‚¹ä¸º 0 0ï¼Œå‘å³ğŸ‘‰å’Œå‘ä¸‹ğŸ‘‡æ˜¯ X Y è½´æ­£æ–¹å‘ï¼Œ0ï¼Œ0 ä¸º pageSlicePos åˆå§‹å€¼
  const pageSlicePos = {  // åæ ‡ç³»çš„åŸç‚¹
    x: 0,
    y: 0,
  };
  var scale = 10; // ç¼©æ”¾æ¯”ä¾‹
  var mapScale = 10; // è°ƒæ•´åœ°å›¾çš„é»˜è®¤çš„ç¼©æ”¾å¤§å°
  // ----------- pageSlicePos, scale è¿™ä¸¤ä¸ªå€¼æ˜¯é‡ç‚¹------------------

  const solidColor = '#ccc'; // å®çº¿é¢œè‰²
  const dashedColor = '#f0f0f0'; // è™šçº¿é¢œè‰²
  const zeroColor = '#358bf3'; // 0 ç‚¹åæ ‡ç³»é¢œè‰²
  const GRIDSIZE = 5;  // ä¸€ä¸ªæ­£æ–¹å½¢ç½‘æ ¼çš„å®½é«˜å¤§å°, ä¸€ä¸ªGRIDSIZEè§†ä¸ºä¸€ä¸ªå•ä½

  const myCanvas = document.querySelector('#myCanvas');
  const ctx = myCanvas.getContext('2d'); // è·å–canvasä¸Šä¸‹æ–‡
  myCanvas.addEventListener("mousedown", mouseDown);
  myCanvas.addEventListener("mousewheel", mouseWheel);
  myCanvas.addEventListener("mousemove", mouseMove);

  const curMousePos = {
    x: 0,
    y: 0
  }

  const arrX = []
  const arrY = []
  // map.features.forEach(item => {
  //   let coordinates = item.geometry.coordinates;
  //   coordinates.forEach(data => {
  //     data.forEach(data1 => {
  //       if (data1.length > 2) {
  //         data1.forEach((data2, i) => {
  //           arrX.push(data2[0]);
  //           arrY.push(data2[1]);
  //         });
  //       }
  //     });
  //   });
  // });
  const left = Math.min(...arrX);
  const right = Math.max(...arrX);
  const topp = Math.min(...arrY);
  const bottom = Math.max(...arrY);
  let mapH = topp + bottom;
  let mapW = left + right;
  let mapCenterPos = [mapW / 2, mapH / 2];

  /**
   * ç»˜åˆ¶ç½‘æ ¼
   * @param scaleVal ç¼©æ”¾å€æ•°
   */
  var drawLineGrid = (scaleVal = scale) => {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    /*è·å–ç»˜å›¾å·¥å…·*/
    // è®¾ç½®ç½‘æ ¼å¤§å°
    var girdSize = getPixelSize(GRIDSIZE);
    // è·å–Canvasçš„widthã€height
    var CanvasWidth = ctx.canvas.width;
    var CanvasHeight = ctx.canvas.height;

    // åœ¨ pageSlicePos çš„ xï¼Œy ç‚¹ä½ç”»ä¸€ä¸ª 10 * 10 çš„çº¢è‰²æ ‡è®°ç”¨æ¥è¡¨ç¤ºå½“å‰é¡µé¢çš„ 0 0 åæ ‡
    ctx.fillStyle = 'red';
    ctx.fillRect(pageSlicePos.x - 5, pageSlicePos.y - 5, 10, 10); // æ•ˆæœå›¾çº¢è‰²å°æ–¹å—

    const canvasXHeight = CanvasHeight - pageSlicePos.y;
    const canvasYWidth = CanvasWidth - pageSlicePos.x;
    // ä» pageSlicePos.y å¤„å¼€å§‹å¾€ Y è½´æ­£æ–¹å‘ç”» X è½´ç½‘æ ¼
    const xPageSliceTotal = Math.ceil(canvasXHeight / girdSize);   // æ¯éš”ä¸€ä¸ªå•ä½ç”»ä¸€æ¡çº¿
    for (let i = 0; i < xPageSliceTotal; i++) {
      ctx.beginPath(); // å¼€å¯è·¯å¾„ï¼Œè®¾ç½®ä¸åŒçš„æ ·å¼
      ctx.moveTo(0, pageSlicePos.y + girdSize * i);
      ctx.lineTo(CanvasWidth, pageSlicePos.y + girdSize * i);
      ctx.strokeStyle = i === 0 ? zeroColor : (i % 5 === 0 ? solidColor : dashedColor); // å¦‚æœä¸º 0 åˆ™ç”¨è“è‰²æ ‡è®°ï¼Œå–ä½™ 5 ä¸ºå®çº¿ï¼Œå…¶ä½™ä¸ºæ¯”è¾ƒæ·¡çš„çº¿
      ctx.stroke();
    }

    // ä» pageSlicePos.y å¤„å¼€å§‹å¾€ Y è½´è´Ÿæ–¹å‘ç”» X è½´ç½‘æ ¼
    const xRemaining = pageSlicePos.y;
    const xRemainingTotal = Math.ceil(xRemaining / girdSize);
    for (let i = 0; i < xRemainingTotal; i++) {
      if (i === 0) continue;
      ctx.beginPath(); // å¼€å¯è·¯å¾„ï¼Œè®¾ç½®ä¸åŒçš„æ ·å¼
      ctx.moveTo(0, pageSlicePos.y - girdSize * i); // -0.5æ˜¯ä¸ºäº†è§£å†³åƒç´ æ¨¡ç³Šé—®é¢˜
      ctx.lineTo(CanvasWidth, pageSlicePos.y - girdSize * i);
      ctx.strokeStyle = i === 0 ? zeroColor : (i % 5 === 0 ? solidColor : dashedColor);// å¦‚æœä¸º 0 åˆ™ç”¨è“è‰²æ ‡è®°ï¼Œå–ä½™ 5 ä¸ºå®çº¿ï¼Œå…¶ä½™ä¸ºæ¯”è¾ƒæ·¡çš„çº¿
      ctx.stroke();
    }

    // ä» pageSlicePos.x å¤„å¼€å§‹å¾€ X è½´æ­£æ–¹å‘ç”» Y è½´ç½‘æ ¼
    const yPageSliceTotal = Math.ceil(canvasYWidth / girdSize); // è®¡ç®—éœ€è¦ç»˜ç”»yè½´çš„æ¡æ•°
    for (let j = 0; j < yPageSliceTotal; j++) {
      ctx.beginPath(); // å¼€å¯è·¯å¾„ï¼Œè®¾ç½®ä¸åŒçš„æ ·å¼
      ctx.moveTo(pageSlicePos.x + girdSize * j, 0);
      ctx.lineTo(pageSlicePos.x + girdSize * j, CanvasHeight);
      ctx.strokeStyle = j === 0 ? zeroColor : (j % 5 === 0 ? solidColor : dashedColor);// å¦‚æœä¸º 0 åˆ™ç”¨è“è‰²æ ‡è®°ï¼Œå–ä½™ 5 ä¸ºå®çº¿ï¼Œå…¶ä½™ä¸ºæ¯”è¾ƒæ·¡çš„çº¿
      ctx.stroke();
    }

    // ä» pageSlicePos.x å¤„å¼€å§‹å¾€ X è½´è´Ÿæ–¹å‘ç”» Y è½´ç½‘æ ¼
    const yRemaining = pageSlicePos.x;
    const yRemainingTotal = Math.ceil(yRemaining / girdSize);
    for (let j = 0; j < yRemainingTotal; j++) {
      if (j === 0) continue;
      ctx.beginPath(); // å¼€å¯è·¯å¾„ï¼Œè®¾ç½®ä¸åŒçš„æ ·å¼
      ctx.moveTo(pageSlicePos.x - girdSize * j, 0);
      ctx.lineTo(pageSlicePos.x - girdSize * j, CanvasHeight);
      ctx.strokeStyle = j === 0 ? zeroColor : (j % 5 === 0 ? solidColor : dashedColor);// å¦‚æœä¸º 0 åˆ™ç”¨è“è‰²æ ‡è®°ï¼Œå–ä½™ 5 ä¸ºå®çº¿ï¼Œå…¶ä½™ä¸ºæ¯”è¾ƒæ·¡çš„çº¿
      ctx.stroke();
    }

    ctx.strokeStyle = "black";
    // map.features.forEach(item => {
    //   console.log(item.properties, "item");
    //   let coordinates = item.geometry.coordinates;
    //   if (item.properties.center && item.properties.center.length == 2) {
    //     let cp = item.properties.center;
    //     let mapX = (cp[0] - mapCenterPos[0]);
    //     let mapY = mapH - (cp[1] + mapCenterPos[1]);
    //     let center = getPixelPos({ x: mapX * mapScale, y: mapY * mapScale });
    //     ctx.fillStyle = "#000"
    //     ctx.fillText(item.properties.name, center.x, center.y);
    //   }
    //   coordinates.forEach(data => {
    //     data.forEach(data1 => {
    //       if (data1.length > 2) {
    //         ctx.beginPath();
    //         data1.forEach((data2, i) => {
    //           let mapX = (data2[0] - mapCenterPos[0]);
    //           let mapY = mapH - (data2[1] + mapCenterPos[1]);
    //           let point = getPixelPos({ x: mapX * mapScale, y: mapY * mapScale });
    //           if (i === 0) {
    //             ctx.moveTo(point.x, point.y);
    //           }
    //           ctx.lineTo(point.x, point.y);
    //         });
    //         ctx.stroke();
    //         let isPointIn = ctx.isPointInPath(curMousePos.x, curMousePos.y);
    //         if (isPointIn) {
    //           ctx.fillStyle = "red";
    //           ctx.fill();
    //         }
    //       }
    //     });
    //   });
    // });
  };

  function mouseMove(e) {
    curMousePos.x = e.clientX;
    curMousePos.y = e.clientY;
  }

  function getPixelPos(point) {
    return {
      x: pageSlicePos.x + (point.x / GRIDSIZE) * scale,
      y: pageSlicePos.y + (point.y / GRIDSIZE) * scale,
    };
  }

  function getRelativePos(point) {
    return {
      x: ((point.x - pageSlicePos.x) / scale) * GRIDSIZE,
      y: ((point.y - pageSlicePos.y) / scale) * GRIDSIZE,
    };
  }

  function getPixelSize(size) {
    return size * scale;
  }

  function getRelativeSize(size) {
    return size / scale;
  }

  /**
   * æ»šè½®ç¼©æ”¾å€æ•°
   */
  function mouseWheel(e) {
    if (e.wheelDelta > 0) {
      if (scale < 20) {
        scale++;
      }
    } else {
      if (scale > 1) {
        scale--;
      }
    }
  }

  /**
   * æ‹–åŠ¨ canvas åŠ¨æ€æ¸²æŸ“ï¼Œæ‹–åŠ¨æ—¶ï¼ŒåŠ¨æ€è®¾ç½® pageSlicePos çš„å€¼
   * @param e Event
   */
  function mouseDown(e) {
    const downX = e.clientX;
    const downY = e.clientY;
    const { x, y } = pageSlicePos;
    myCanvas.onmousemove = (ev) => {
      const moveX = ev.clientX;
      const moveY = ev.clientY;
      pageSlicePos.x = x + (moveX - downX);
      pageSlicePos.y = y + (moveY - downY);
      myCanvas.onmouseup = (en) => {
        myCanvas.onmousemove = null;
        myCanvas.onmouseup = null;
      };
    }
    myCanvas.onmouseup = (en) => {
      myCanvas.onmousemove = null;
      myCanvas.onmouseup = null;
    };
  }

  (function main() {
    drawLineGrid();
    requestAnimationFrame(main);
  })()

</script>
<style>
  body {
    margin: 0;
  }
</style>